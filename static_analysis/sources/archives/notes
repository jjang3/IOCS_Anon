#!/bin/sh
#
# Copyright (C) 2022 National University of Singapore
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

if [ -t 1 ]
then
    RED="\033[31m"
    GREEN="\033[32m"
    YELLOW="\033[33m"
    BOLD="\033[1m"
    OFF="\033[0m"
else
    RED=
    GREEN=
    YELLOW=
    BOLD=
    OFF=
fi

if [ $# -lt 1 ]
then
    echo "${YELLOW}usage${OFF}: $0 file.c EXTRA_ARGS" >&2
    exit 1
fi

case "$1" in
    *.s)
        CC=gcc
        EXTENSION=s
        ;;
    *.c)
        CC=gcc
        EXTENSION=c
        ;;
    *.cpp)
        CC=g++
        EXTENSION=cpp
        ;;
    *)
        echo >&2
        echo "${RED}error${OFF}: file $1 must have a .c/.cpp/.s extension" >&2
        echo >&2
        exit 1
        ;;
esac
BASENAME=`basename $1 .$EXTENSION`
DIRNAME=`dirname $1`

shift

CFLAGS="-fno-stack-protector \
    -fpie -O2 -Wno-unused-function \
    -mno-mmx -mno-sse -mno-avx -mno-avx2 -mno-avx512f -msoft-float \
    -fno-tree-vectorize -fomit-frame-pointer \
    -I examples/ "
COMPILE="$CC $CFLAGS -c -Wall $@ $HOME/Waterfall/pku/src/pkuapi.c  \"$DIRNAME/$BASENAME.$EXTENSION\"" 
# Had to add stuff here. $HOME/Waterfall/pku/src/pkuapi.c <- put after $@
echo "$COMPILE" | xargs
if ! eval "$COMPILE"
then
    echo >&2
    echo "${RED}error${OFF}: compilation of (${YELLOW}$BASENAME${OFF}) failed" >&2
    echo >&2
    exit 1
fi

CFLAGS="-pie -nostdlib \
    -Wl,-z -Wl,max-page-size=4096 \
    -Wl,-z -Wl,norelro \
    -Wl,-z -Wl,stack-size=0 \
    -Wl,--export-dynamic \
    -Wl,--entry=0x0 \
    -Wl,--strip-all"
COMPILE="$CC \"$BASENAME.o\" $HOME/Waterfall/e9stuff/pkuapi.o -o \"$BASENAME\" $CFLAGS"
# Had to add stuff here. $HOME/Waterfall/e9stuff/pkuapi.o  <- put after BASENAME.o
echo "$COMPILE" | xargs
if ! eval "$COMPILE"
then
    echo >&2
    echo "${RED}error${OFF}: linking (${YELLOW}$BASENAME${OFF}) failed" >&2
    echo >&2
    exit 1
fi

RELOCS=`readelf -r "$BASENAME" | head -n 10 | grep 'R_X86_64_'`
if [ ! -z "$RELOCS" ]
then
    echo >&2
    echo "${RED}error${OFF}: the generated file (${YELLOW}$BASENAME${OFF}) contains relocations" >&2
    echo >&2
    echo "EXPLANATION:" >&2
    echo >&2
    echo "    E9Tool's call instrumentation does not support relocations.  These are" >&2
    echo "    usually caused by global variables that contain pointers, e.g.:" >&2
    echo >&2
    echo "      ${YELLOW}const char *days[] = {\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"};${OFF}" >&2
    echo >&2
    echo "    Here, the global variable days[] is an array-of-pointers which usually" >&2
    echo "    results in relocations in the instrumentation binary.  Currently, E9Tool's" >&2
    echo "    call instrumentation does not apply relocations, meaning that the final" >&2
    echo "    patched binary using the instrumentation may crash." >&2
    echo >&2
    echo "    It may be possible to rewrite code to avoid relocations in exchange for" >&2
    echo "    extra padding, e.g.:" >&2
    echo >&2
    echo "      ${YELLOW}const char days[][4] = {\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"};${OFF}" >&2
    echo >&2
    exit 1
fi

exit 0


PTACallGraph *buildDTAInputGraph(SVFModule *input, PTACallGraph *PTACG) 
{
    PTACallGraph *output = new PTACallGraph();
    
    auto &callInstToCGEdgesM = PTACG->getCallInstToCallGraphEdgesMap();
    for (auto mapIt = callInstToCGEdgesM.begin(); mapIt != callInstToCGEdgesM.end(); mapIt++) {
        auto *cbNode = mapIt->first;
        auto cgEdgeSet = mapIt->second;
        
        #if 0
        auto *caller = cbNode->getCaller();
        auto *callsite = cbNode->getCallSite();
        #endif

        PTACallGraph::FunctionSet funSet;
        PTACG->getCallees(cbNode, funSet);

        for (auto funSetIt = funSet.begin(); funSetIt != funSet.end(); funSetIt++) {
            const SVFFunction *callee = *funSetIt;
            icfg_dbg << callee->getName().c_str() << "\n";
        }

        // iterate each ICFGNode on ICFG
        for(PTACallGraph::iterator i = PTACG->begin(); i != PTACG->end(); i++)
        {
           // auto *n = i->second;
        }

    
    }
    #if 0
    for (SVFModule::const_iterator F = input->begin(), FE = input->end(); F != FE; ++F)
    {
        const SVFFunction *svfFun = *F;
        for (SVFFunction::const_iterator BB = svfFun->begin(), BE = svfFun->end(); BB != BE; ++BB)
        {
            const SVFBasicBlock *svfBB = *BB;
            for (SVFBasicBlock::const_iterator I = svfBB->begin(), IE = svfBB->end(); I != IE; ++I)
            {
                const SVFInstruction *svfI = *I;
            }
        }
        output->addCallGraphNode(*F);
    }
    #endif
    #if 0
    for (SVFModule::const_iterator F = input->begin(), E = input->end(); F != E; ++F)
    {
        for (const SVFBasicBlock* svfbb : (*F)->getBasicBlockList())
        {
            for (const SVFInstruction* inst : svfbb->getInstructionList())
            {
                if(isCallSite(inst))
                {
                    auto instCallSite = getSVFCallSite(inst);
                    auto instCallee  = getCallee(instCallSite);
                    const CallICFGNode* callBlockNode = icfg->getCallICFGNode(inst);
                    output->addDirectCallGraphEdge(callBlockNode, *F, instCallee);
                    icfg_dbg << "Found: " << inst->toString() << " " << inst->getFunction()->toString() << "\n";
                }
            }
        }
    }
    #endif
    return output;
}

vector<ICFGNode*> getAllICFGStartPoints(ICFG* icfg) {
	int counter = 1;
	vector<ICFGNode*> startingPoints;
	for(ICFG::iterator i = icfg->begin(); i != icfg->end(); i++) {
		ICFGNode* node = i->second;
		if (!node->hasIncomingEdge()) {
			unordered_set<NodeID> visited;
			// SVFUtil::outs() << "STARTPOINT COUNTER: " << counter << "\n";
			startingPoints.push_back(node);
			counter++;
		}
	}
	return startingPoints;
}
    //pag->dump(graphName);
    // iterate each ICFGNode on ICFG
    #if 0
    vector<ICFGNode*> startingPoints = getAllICFGStartPoints(icfg);
    for (auto item : startingPoints)
    {
        //SVFUtil::outs() << item->toString() << "\n";
    }
    #endif
    #if 0
    for(ICFG::iterator inode = icfg->begin(); inode != icfg->end(); inode++)
    {
        ICFGNode *n = inode->second;
        //SVFUtil::outs() << n->toString() << "\n";
        // for(ICFGEdge* edge : n->getOutEdges()){
        //     SVFUtil::outs() << edge->toString() << "\n";
        // }
        #if 0
        
        else if (SVFUtil::isa<IntraICFGNode>(n))
        {
            icfg_dbg << "IntraICFG: " << n->toString().c_str() << "\n";
        }
        #endif
        #if 1
        if (SVFUtil::isa<FunEntryICFGNode>(n))
        {
            icfg_dbg << "Fun entry: " << n->toString().c_str() << "\n";
        }
        if (SVFUtil::isa<CallICFGNode>(n)) { 
            CallICFGNode* callNode =  SVFUtil::cast<CallICFGNode>(n);
            /*
            if (callNode->getSVFStmts().empty())
                icfg_dbg << callNode->toString().c_str() << " " <<  callNode->getCallSite()->toString().c_str() << "\n";
            */
            //const SVFInstruction* svfInst = callNode->getCallSite();
            //auto sourceLoc =  callNode->getCallSite()->getFunction()->getSourceLoc();
            //icfg_dbg << svfInst->toString().c_str() << " Line number: " << sourceLoc << "\n";
        } 
        #endif         
    }
    #endif
    /// Create Andersen's pointer analysis
    //Andersen* ander = AndersenWaveDiff::createAndersenWaveDiff(pag);
    //ander->getPTACallGraph()->dump(graphName);

    #if 0
    /// Sparse value-flow graph (SVFG)
    SVFGBuilder svfBuilder(true);
    //SVFG* svfg =
    auto svfg_build = svfBuilder.buildFullSVFG(ander);

    for(auto i = svfg_build->begin(); i != svfg_build->end(); i++)
    {
        //icfg_dbg << i->second->Addr  << "\n";
    }
    #endif
    // Create graph nodes without intrinsic functions
    //callgraph = buildDTAInputGraph(svfModule, ander->getPTACallGraph());
    //callgraph->dump(graphName);
    //AnalysisResult = extractCallGraph(M, callgraph);
    

Script:

#mov.+\(%rax.*
#cd $E9BIN_DIR && e9tool -M 'asm=/xor.+%rax.*/' -P 'after entry(offset,asm,"entry")@trampoline' $INPUT_DIR/$2.out
#cd $E9BIN_DIR && e9tool -M 'call and target = &__cyg_profile_func_enter' -P 'before entry(offset,asm,"entry")@trampoline' -M 'call and target = &__cyg_profile_func_exit' -P 'before entry(offset,asm,"exit")@trampoline' $INPUT_DIR/$2.out
#e9toolc -P 'before entry(offset,asm,"entry")@trampoline' -M 'call and target = &__cyg_profile_func_exit' -P 'before entry(offset,asm,"exit")@trampoline' $INPUT_DIR/$2.out
#TEST_TARGET='"-M '"call and target = &__cyg_profile_func_exit"' -P print"'

TEST_TARGET='-M '"call and target = &__cyg_profile_func_exit"''
TEST_PATCH='-P '"before entry(offset,asm,\"exit\")@trampoline"''

cd $E9BIN_DIR && 
e9tool \
for i in ${ISO_LIST//,/};
do
"$TEST_TARGET" \
"-P print" \
done
$INPUT_DIR/$2.out

mv $E9BIN_DIR/a.out $OUTPUT_DIR/$2.out

#cd $E9BIN_DIR &&
#e9tool "$TEST_TARGET" \
#$INPUT_DIR/$2.out
#TEST="'-M \'call and target = &__cyg_profile_func_exit\' "-P "print"

#TEST_TARGET="-M 'call and target = &__cyg_profile_func_exit' -P print"
#TEST_PATCH='-P '"before entry(offset,asm,\"exit\")@trampoline"''

#echo $TEST_TARGET
#cd $E9BIN_DIR &&
#e9tool \
#$TEST_TARGET \
#$INPUT_DIR/$2.out
#cd $E9BIN_DIR &&
#e9tool \

: <<'END_COMMENT'

    '-M '"call and target = &__cyg_profile_func_exit"'' \
    '-P '"before entry(offset,asm,\"exit\")@trampoline"'' \
cd $E9BIN_DIR
#e9tool 
$INPUT_DIR/$2.out
"$TEST_TARGET" "$TEST_PATCH" \
$INPUT_DIR/$2.out

mv $E9BIN_DIR/a.out $OUTPUT_DIR/$2.out

PATCHING_TARGETS=""
for i in ${ISO_LIST//,/" "}
do
    PATCHING_TARGETS+="-M '\''call and target = &$i'\'' -P '\''before entry(offset,asm,\"entry\")@trampoline'\'' " 
done
PATCHING_TARGETS+="-M 'call and target = &__cyg_profile_func_exit' -P 'before entry(offset,asm,"exit")@trampoline'"
echo $PATCHING_TARGETS
#EQ="("
#EQ2=")"
#TEST_TARGET="-M \'call and target = &__cyg_profile_func_exit\' "-P" \'before entry${EQ}offset,asm,asm${EQ2}@trampoline\'"
#TEST="-M 'call and target = &__cyg_profile_func_exit' -P 'before entry(offset,asm,"exit")@trampoline"
#TEST=`-M "call and target = &__cyg_profile_func_exit" -P "before entry(offset,asm,"exit")@trampoline"`
#TEST_TEST="-M '\''call and target = &__cyg_profile_func_exit'\''"
#TEST_TEST_TEST="-P '\''before entry(offset,asm,asm)@trampoline'\''"
#TEST_2="-P \'before entry(offset,asm,"exit")@trampoline\'"
TEST_TARGET='-M '"call and target = &__cyg_profile_func_exit"''
TEST_PATCH='-P '"before entry(offset,asm,\"exit\")@trampoline"''

cd $E9BIN_DIR &&
e9tool \
"$TEST_TARGET" "$TEST_PATCH" \
for i in ${ISO_LIST//,/};
do
    echo $i
done
$INPUT_DIR/$2.out


#e9tool "$TEST" $INPUT_DIR/$2.out #"$TEST_2" 
#echo $TEST
#echo $PATCHING_TARGETS
#echo "e9tool $TEST_TARGET $INPUT_DIR/$2.out"
#e9tool $TEST_TARGET $INPUT_DIR/$2.out
#$PATCHING_TARGETS
#-M 'call and target = &__cyg_profile_func_exit' -P 'before entry(offset,asm,"exit")@trampoline' \

mv $E9BIN_DIR/a.out $OUTPUT_DIR/$2.out
##-M 'call and target = &process_new_data' -P 'before entry(offset,asm,"entry")@trampoline' \
END_COMMENT